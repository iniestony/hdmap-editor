// This Source Code Form is subject to the terms of the Mozilla Public
// License, v2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.1
 * source: map/map.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

import * as dependency_1 from "./map_clear_area";
import * as dependency_2 from "./map_crosswalk";
import * as dependency_3 from "./map_junction";
import * as dependency_4 from "./map_lane";
import * as dependency_5 from "./map_overlap";
import * as dependency_11 from "./map_parking_space";
import * as dependency_12 from "./map_pnc_junction";
import * as dependency_10 from "./map_road";
import * as dependency_13 from "./map_rsu";
import * as dependency_6 from "./map_signal";
import * as dependency_7 from "./map_speed_bump";
import * as dependency_8 from "./map_stop_sign";
import * as dependency_9 from "./map_yield_sign";

export namespace atlas.hdmap {
  export class Projection extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            proj?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("proj" in data && data.proj != undefined) {
          this.proj = data.proj;
        }
      }
    }
    get proj() {
      return pb_1.Message.getField(this, 1) as string;
    }
    set proj(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { proj?: string }) {
      const message = new Projection({});
      if (data.proj != null) {
        message.proj = data.proj;
      }
      return message;
    }
    toObject() {
      const data: {
        proj?: string;
      } = {};
      if (this.proj != null) {
        data.proj = this.proj;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (typeof this.proj === "string" && this.proj.length) {
        writer.writeString(1, this.proj);
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Projection {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Projection();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            message.proj = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Projection {
      return Projection.deserialize(bytes);
    }
  }
  export class Header extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            version?: Uint8Array;
            date?: Uint8Array;
            projection?: Projection;
            district?: Uint8Array;
            generation?: Uint8Array;
            rev_major?: Uint8Array;
            rev_minor?: Uint8Array;
            left?: number;
            top?: number;
            right?: number;
            bottom?: number;
            vendor?: Uint8Array;
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("version" in data && data.version != undefined) {
          this.version = data.version;
        }
        if ("date" in data && data.date != undefined) {
          this.date = data.date;
        }
        if ("projection" in data && data.projection != undefined) {
          this.projection = data.projection;
        }
        if ("district" in data && data.district != undefined) {
          this.district = data.district;
        }
        if ("generation" in data && data.generation != undefined) {
          this.generation = data.generation;
        }
        if ("rev_major" in data && data.rev_major != undefined) {
          this.rev_major = data.rev_major;
        }
        if ("rev_minor" in data && data.rev_minor != undefined) {
          this.rev_minor = data.rev_minor;
        }
        if ("left" in data && data.left != undefined) {
          this.left = data.left;
        }
        if ("top" in data && data.top != undefined) {
          this.top = data.top;
        }
        if ("right" in data && data.right != undefined) {
          this.right = data.right;
        }
        if ("bottom" in data && data.bottom != undefined) {
          this.bottom = data.bottom;
        }
        if ("vendor" in data && data.vendor != undefined) {
          this.vendor = data.vendor;
        }
      }
    }
    get version() {
      return pb_1.Message.getField(this, 1) as Uint8Array;
    }
    set version(value: Uint8Array) {
      pb_1.Message.setField(this, 1, value);
    }
    get date() {
      return pb_1.Message.getField(this, 2) as Uint8Array;
    }
    set date(value: Uint8Array) {
      pb_1.Message.setField(this, 2, value);
    }
    get projection() {
      return pb_1.Message.getWrapperField(this, Projection, 3);
    }
    set projection(value: Projection) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get district() {
      return pb_1.Message.getField(this, 4) as Uint8Array;
    }
    set district(value: Uint8Array) {
      pb_1.Message.setField(this, 4, value);
    }
    get generation() {
      return pb_1.Message.getField(this, 5) as Uint8Array;
    }
    set generation(value: Uint8Array) {
      pb_1.Message.setField(this, 5, value);
    }
    get rev_major() {
      return pb_1.Message.getField(this, 6) as Uint8Array;
    }
    set rev_major(value: Uint8Array) {
      pb_1.Message.setField(this, 6, value);
    }
    get rev_minor() {
      return pb_1.Message.getField(this, 7) as Uint8Array;
    }
    set rev_minor(value: Uint8Array) {
      pb_1.Message.setField(this, 7, value);
    }
    get left() {
      return pb_1.Message.getField(this, 8) as number;
    }
    set left(value: number) {
      pb_1.Message.setField(this, 8, value);
    }
    get top() {
      return pb_1.Message.getField(this, 9) as number;
    }
    set top(value: number) {
      pb_1.Message.setField(this, 9, value);
    }
    get right() {
      return pb_1.Message.getField(this, 10) as number;
    }
    set right(value: number) {
      pb_1.Message.setField(this, 10, value);
    }
    get bottom() {
      return pb_1.Message.getField(this, 11) as number;
    }
    set bottom(value: number) {
      pb_1.Message.setField(this, 11, value);
    }
    get vendor() {
      return pb_1.Message.getField(this, 12) as Uint8Array;
    }
    set vendor(value: Uint8Array) {
      pb_1.Message.setField(this, 12, value);
    }
    static fromObject(data: {
      version?: Uint8Array;
      date?: Uint8Array;
      projection?: ReturnType<typeof Projection.prototype.toObject>;
      district?: Uint8Array;
      generation?: Uint8Array;
      rev_major?: Uint8Array;
      rev_minor?: Uint8Array;
      left?: number;
      top?: number;
      right?: number;
      bottom?: number;
      vendor?: Uint8Array;
    }) {
      const message = new Header({});
      if (data.version != null) {
        message.version = data.version;
      }
      if (data.date != null) {
        message.date = data.date;
      }
      if (data.projection != null) {
        message.projection = Projection.fromObject(data.projection);
      }
      if (data.district != null) {
        message.district = data.district;
      }
      if (data.generation != null) {
        message.generation = data.generation;
      }
      if (data.rev_major != null) {
        message.rev_major = data.rev_major;
      }
      if (data.rev_minor != null) {
        message.rev_minor = data.rev_minor;
      }
      if (data.left != null) {
        message.left = data.left;
      }
      if (data.top != null) {
        message.top = data.top;
      }
      if (data.right != null) {
        message.right = data.right;
      }
      if (data.bottom != null) {
        message.bottom = data.bottom;
      }
      if (data.vendor != null) {
        message.vendor = data.vendor;
      }
      return message;
    }
    toObject() {
      const data: {
        version?: Uint8Array;
        date?: Uint8Array;
        projection?: ReturnType<typeof Projection.prototype.toObject>;
        district?: Uint8Array;
        generation?: Uint8Array;
        rev_major?: Uint8Array;
        rev_minor?: Uint8Array;
        left?: number;
        top?: number;
        right?: number;
        bottom?: number;
        vendor?: Uint8Array;
      } = {};
      if (this.version != null) {
        data.version = this.version;
      }
      if (this.date != null) {
        data.date = this.date;
      }
      if (this.projection != null) {
        data.projection = this.projection.toObject();
      }
      if (this.district != null) {
        data.district = this.district;
      }
      if (this.generation != null) {
        data.generation = this.generation;
      }
      if (this.rev_major != null) {
        data.rev_major = this.rev_major;
      }
      if (this.rev_minor != null) {
        data.rev_minor = this.rev_minor;
      }
      if (this.left != null) {
        data.left = this.left;
      }
      if (this.top != null) {
        data.top = this.top;
      }
      if (this.right != null) {
        data.right = this.right;
      }
      if (this.bottom != null) {
        data.bottom = this.bottom;
      }
      if (this.vendor != null) {
        data.vendor = this.vendor;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.version !== undefined) {
        writer.writeBytes(1, this.version);
      }
      if (this.date !== undefined) {
        writer.writeBytes(2, this.date);
      }
      if (this.projection !== undefined) {
        writer.writeMessage(3, this.projection, () => this.projection.serialize(writer));
      }
      if (this.district !== undefined) {
        writer.writeBytes(4, this.district);
      }
      if (this.generation !== undefined) {
        writer.writeBytes(5, this.generation);
      }
      if (this.rev_major !== undefined) {
        writer.writeBytes(6, this.rev_major);
      }
      if (this.rev_minor !== undefined) {
        writer.writeBytes(7, this.rev_minor);
      }
      if (this.left !== undefined) {
        writer.writeDouble(8, this.left);
      }
      if (this.top !== undefined) {
        writer.writeDouble(9, this.top);
      }
      if (this.right !== undefined) {
        writer.writeDouble(10, this.right);
      }
      if (this.bottom !== undefined) {
        writer.writeDouble(11, this.bottom);
      }
      if (this.vendor !== undefined) {
        writer.writeBytes(12, this.vendor);
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Header {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Header();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            message.version = reader.readBytes();
            break;
          case 2:
            message.date = reader.readBytes();
            break;
          case 3:
            reader.readMessage(
              message.projection,
              () => (message.projection = Projection.deserialize(reader)),
            );
            break;
          case 4:
            message.district = reader.readBytes();
            break;
          case 5:
            message.generation = reader.readBytes();
            break;
          case 6:
            message.rev_major = reader.readBytes();
            break;
          case 7:
            message.rev_minor = reader.readBytes();
            break;
          case 8:
            message.left = reader.readDouble();
            break;
          case 9:
            message.top = reader.readDouble();
            break;
          case 10:
            message.right = reader.readDouble();
            break;
          case 11:
            message.bottom = reader.readDouble();
            break;
          case 12:
            message.vendor = reader.readBytes();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Header {
      return Header.deserialize(bytes);
    }
  }
  export class Map extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            header?: Header;
            crosswalk: dependency_2.atlas.hdmap.Crosswalk[];
            junction: dependency_3.atlas.hdmap.Junction[];
            lane: dependency_4.atlas.hdmap.Lane[];
            stop_sign: dependency_8.atlas.hdmap.StopSign[];
            signal: dependency_6.atlas.hdmap.Signal[];
            yield: dependency_9.atlas.hdmap.YieldSign[];
            overlap: dependency_5.atlas.hdmap.Overlap[];
            clear_area: dependency_1.atlas.hdmap.ClearArea[];
            speed_bump: dependency_7.atlas.hdmap.SpeedBump[];
            road: dependency_10.atlas.hdmap.Road[];
            parking_space: dependency_11.atlas.hdmap.ParkingSpace[];
            pnc_junction: dependency_12.atlas.hdmap.PNCJunction[];
            rsu: dependency_13.atlas.hdmap.RSU[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
        [],
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("header" in data && data.header != undefined) {
          this.header = data.header;
        }
        this.crosswalk = data.crosswalk;
        this.junction = data.junction;
        this.lane = data.lane;
        this.stop_sign = data.stop_sign;
        this.signal = data.signal;
        this.yield = data.yield;
        this.overlap = data.overlap;
        this.clear_area = data.clear_area;
        this.speed_bump = data.speed_bump;
        this.road = data.road;
        this.parking_space = data.parking_space;
        this.pnc_junction = data.pnc_junction;
        this.rsu = data.rsu;
      }
    }
    get header() {
      return pb_1.Message.getWrapperField(this, Header, 1);
    }
    set header(value: Header) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get crosswalk() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_2.atlas.hdmap.Crosswalk, 2);
    }
    set crosswalk(value: dependency_2.atlas.hdmap.Crosswalk[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get junction() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_3.atlas.hdmap.Junction, 3);
    }
    set junction(value: dependency_3.atlas.hdmap.Junction[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get lane() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.atlas.hdmap.Lane, 4);
    }
    set lane(value: dependency_4.atlas.hdmap.Lane[]) {
      pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get stop_sign() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_8.atlas.hdmap.StopSign, 5);
    }
    set stop_sign(value: dependency_8.atlas.hdmap.StopSign[]) {
      pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get signal() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_6.atlas.hdmap.Signal, 6);
    }
    set signal(value: dependency_6.atlas.hdmap.Signal[]) {
      pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get yield() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_9.atlas.hdmap.YieldSign, 7);
    }
    set yield(value: dependency_9.atlas.hdmap.YieldSign[]) {
      pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    get overlap() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_5.atlas.hdmap.Overlap, 8);
    }
    set overlap(value: dependency_5.atlas.hdmap.Overlap[]) {
      pb_1.Message.setRepeatedWrapperField(this, 8, value);
    }
    get clear_area() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.ClearArea, 9);
    }
    set clear_area(value: dependency_1.atlas.hdmap.ClearArea[]) {
      pb_1.Message.setRepeatedWrapperField(this, 9, value);
    }
    get speed_bump() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_7.atlas.hdmap.SpeedBump, 10);
    }
    set speed_bump(value: dependency_7.atlas.hdmap.SpeedBump[]) {
      pb_1.Message.setRepeatedWrapperField(this, 10, value);
    }
    get road() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_10.atlas.hdmap.Road, 11);
    }
    set road(value: dependency_10.atlas.hdmap.Road[]) {
      pb_1.Message.setRepeatedWrapperField(this, 11, value);
    }
    get parking_space() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_11.atlas.hdmap.ParkingSpace, 12);
    }
    set parking_space(value: dependency_11.atlas.hdmap.ParkingSpace[]) {
      pb_1.Message.setRepeatedWrapperField(this, 12, value);
    }
    get pnc_junction() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_12.atlas.hdmap.PNCJunction, 13);
    }
    set pnc_junction(value: dependency_12.atlas.hdmap.PNCJunction[]) {
      pb_1.Message.setRepeatedWrapperField(this, 13, value);
    }
    get rsu() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_13.atlas.hdmap.RSU, 14);
    }
    set rsu(value: dependency_13.atlas.hdmap.RSU[]) {
      pb_1.Message.setRepeatedWrapperField(this, 14, value);
    }
    static fromObject(data: {
      header?: ReturnType<typeof Header.prototype.toObject>;
      crosswalk: ReturnType<typeof dependency_2.atlas.hdmap.Crosswalk.prototype.toObject>[];
      junction: ReturnType<typeof dependency_3.atlas.hdmap.Junction.prototype.toObject>[];
      lane: ReturnType<typeof dependency_4.atlas.hdmap.Lane.prototype.toObject>[];
      stop_sign: ReturnType<typeof dependency_8.atlas.hdmap.StopSign.prototype.toObject>[];
      signal: ReturnType<typeof dependency_6.atlas.hdmap.Signal.prototype.toObject>[];
      yield: ReturnType<typeof dependency_9.atlas.hdmap.YieldSign.prototype.toObject>[];
      overlap: ReturnType<typeof dependency_5.atlas.hdmap.Overlap.prototype.toObject>[];
      clear_area: ReturnType<typeof dependency_1.atlas.hdmap.ClearArea.prototype.toObject>[];
      speed_bump: ReturnType<typeof dependency_7.atlas.hdmap.SpeedBump.prototype.toObject>[];
      road: ReturnType<typeof dependency_10.atlas.hdmap.Road.prototype.toObject>[];
      parking_space: ReturnType<typeof dependency_11.atlas.hdmap.ParkingSpace.prototype.toObject>[];
      pnc_junction: ReturnType<typeof dependency_12.atlas.hdmap.PNCJunction.prototype.toObject>[];
      rsu: ReturnType<typeof dependency_13.atlas.hdmap.RSU.prototype.toObject>[];
    }) {
      const message = new Map({
        crosswalk: data.crosswalk.map((item) =>
          dependency_2.atlas.hdmap.Crosswalk.fromObject(item),
        ),
        junction: data.junction.map((item) => dependency_3.atlas.hdmap.Junction.fromObject(item)),
        lane: data.lane.map((item) => dependency_4.atlas.hdmap.Lane.fromObject(item)),
        stop_sign: data.stop_sign.map((item) => dependency_8.atlas.hdmap.StopSign.fromObject(item)),
        signal: data.signal.map((item) => dependency_6.atlas.hdmap.Signal.fromObject(item)),
        yield: data.yield.map((item) => dependency_9.atlas.hdmap.YieldSign.fromObject(item)),
        overlap: data.overlap.map((item) => dependency_5.atlas.hdmap.Overlap.fromObject(item)),
        clear_area: data.clear_area.map((item) =>
          dependency_1.atlas.hdmap.ClearArea.fromObject(item),
        ),
        speed_bump: data.speed_bump.map((item) =>
          dependency_7.atlas.hdmap.SpeedBump.fromObject(item),
        ),
        road: data.road.map((item) => dependency_10.atlas.hdmap.Road.fromObject(item)),
        parking_space: data.parking_space.map((item) =>
          dependency_11.atlas.hdmap.ParkingSpace.fromObject(item),
        ),
        pnc_junction: data.pnc_junction.map((item) =>
          dependency_12.atlas.hdmap.PNCJunction.fromObject(item),
        ),
        rsu: data.rsu.map((item) => dependency_13.atlas.hdmap.RSU.fromObject(item)),
      });
      if (data.header != null) {
        message.header = Header.fromObject(data.header);
      }
      return message;
    }
    toObject() {
      const data: {
        header?: ReturnType<typeof Header.prototype.toObject>;
        crosswalk: ReturnType<typeof dependency_2.atlas.hdmap.Crosswalk.prototype.toObject>[];
        junction: ReturnType<typeof dependency_3.atlas.hdmap.Junction.prototype.toObject>[];
        lane: ReturnType<typeof dependency_4.atlas.hdmap.Lane.prototype.toObject>[];
        stop_sign: ReturnType<typeof dependency_8.atlas.hdmap.StopSign.prototype.toObject>[];
        signal: ReturnType<typeof dependency_6.atlas.hdmap.Signal.prototype.toObject>[];
        yield: ReturnType<typeof dependency_9.atlas.hdmap.YieldSign.prototype.toObject>[];
        overlap: ReturnType<typeof dependency_5.atlas.hdmap.Overlap.prototype.toObject>[];
        clear_area: ReturnType<typeof dependency_1.atlas.hdmap.ClearArea.prototype.toObject>[];
        speed_bump: ReturnType<typeof dependency_7.atlas.hdmap.SpeedBump.prototype.toObject>[];
        road: ReturnType<typeof dependency_10.atlas.hdmap.Road.prototype.toObject>[];
        parking_space: ReturnType<
          typeof dependency_11.atlas.hdmap.ParkingSpace.prototype.toObject
        >[];
        pnc_junction: ReturnType<typeof dependency_12.atlas.hdmap.PNCJunction.prototype.toObject>[];
        rsu: ReturnType<typeof dependency_13.atlas.hdmap.RSU.prototype.toObject>[];
      } = {
        crosswalk: this.crosswalk.map((item: dependency_2.atlas.hdmap.Crosswalk) =>
          item.toObject(),
        ),
        junction: this.junction.map((item: dependency_3.atlas.hdmap.Junction) => item.toObject()),
        lane: this.lane.map((item: dependency_4.atlas.hdmap.Lane) => item.toObject()),
        stop_sign: this.stop_sign.map((item: dependency_8.atlas.hdmap.StopSign) => item.toObject()),
        signal: this.signal.map((item: dependency_6.atlas.hdmap.Signal) => item.toObject()),
        yield: this.yield.map((item: dependency_9.atlas.hdmap.YieldSign) => item.toObject()),
        overlap: this.overlap.map((item: dependency_5.atlas.hdmap.Overlap) => item.toObject()),
        clear_area: this.clear_area.map((item: dependency_1.atlas.hdmap.ClearArea) =>
          item.toObject(),
        ),
        speed_bump: this.speed_bump.map((item: dependency_7.atlas.hdmap.SpeedBump) =>
          item.toObject(),
        ),
        road: this.road.map((item: dependency_10.atlas.hdmap.Road) => item.toObject()),
        parking_space: this.parking_space.map((item: dependency_11.atlas.hdmap.ParkingSpace) =>
          item.toObject(),
        ),
        pnc_junction: this.pnc_junction.map((item: dependency_12.atlas.hdmap.PNCJunction) =>
          item.toObject(),
        ),
        rsu: this.rsu.map((item: dependency_13.atlas.hdmap.RSU) => item.toObject()),
      };
      if (this.header != null) {
        data.header = this.header.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.header !== undefined) {
        writer.writeMessage(1, this.header, () => this.header.serialize(writer));
      }
      if (this.crosswalk !== undefined) {
        writer.writeRepeatedMessage(2, this.crosswalk, (item: dependency_2.atlas.hdmap.Crosswalk) =>
          item.serialize(writer),
        );
      }
      if (this.junction !== undefined) {
        writer.writeRepeatedMessage(3, this.junction, (item: dependency_3.atlas.hdmap.Junction) =>
          item.serialize(writer),
        );
      }
      if (this.lane !== undefined) {
        writer.writeRepeatedMessage(4, this.lane, (item: dependency_4.atlas.hdmap.Lane) =>
          item.serialize(writer),
        );
      }
      if (this.stop_sign !== undefined) {
        writer.writeRepeatedMessage(5, this.stop_sign, (item: dependency_8.atlas.hdmap.StopSign) =>
          item.serialize(writer),
        );
      }
      if (this.signal !== undefined) {
        writer.writeRepeatedMessage(6, this.signal, (item: dependency_6.atlas.hdmap.Signal) =>
          item.serialize(writer),
        );
      }
      if (this.yield !== undefined) {
        writer.writeRepeatedMessage(7, this.yield, (item: dependency_9.atlas.hdmap.YieldSign) =>
          item.serialize(writer),
        );
      }
      if (this.overlap !== undefined) {
        writer.writeRepeatedMessage(8, this.overlap, (item: dependency_5.atlas.hdmap.Overlap) =>
          item.serialize(writer),
        );
      }
      if (this.clear_area !== undefined) {
        writer.writeRepeatedMessage(
          9,
          this.clear_area,
          (item: dependency_1.atlas.hdmap.ClearArea) => item.serialize(writer),
        );
      }
      if (this.speed_bump !== undefined) {
        writer.writeRepeatedMessage(
          10,
          this.speed_bump,
          (item: dependency_7.atlas.hdmap.SpeedBump) => item.serialize(writer),
        );
      }
      if (this.road !== undefined) {
        writer.writeRepeatedMessage(11, this.road, (item: dependency_10.atlas.hdmap.Road) =>
          item.serialize(writer),
        );
      }
      if (this.parking_space !== undefined) {
        writer.writeRepeatedMessage(
          12,
          this.parking_space,
          (item: dependency_11.atlas.hdmap.ParkingSpace) => item.serialize(writer),
        );
      }
      if (this.pnc_junction !== undefined) {
        writer.writeRepeatedMessage(
          13,
          this.pnc_junction,
          (item: dependency_12.atlas.hdmap.PNCJunction) => item.serialize(writer),
        );
      }
      if (this.rsu !== undefined) {
        writer.writeRepeatedMessage(14, this.rsu, (item: dependency_13.atlas.hdmap.RSU) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Map();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.header, () => (message.header = Header.deserialize(reader)));
            break;
          case 2:
            reader.readMessage(message.crosswalk, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                dependency_2.atlas.hdmap.Crosswalk.deserialize(reader),
                dependency_2.atlas.hdmap.Crosswalk,
              ),
            );
            break;
          case 3:
            reader.readMessage(message.junction, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                3,
                dependency_3.atlas.hdmap.Junction.deserialize(reader),
                dependency_3.atlas.hdmap.Junction,
              ),
            );
            break;
          case 4:
            reader.readMessage(message.lane, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                4,
                dependency_4.atlas.hdmap.Lane.deserialize(reader),
                dependency_4.atlas.hdmap.Lane,
              ),
            );
            break;
          case 5:
            reader.readMessage(message.stop_sign, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                5,
                dependency_8.atlas.hdmap.StopSign.deserialize(reader),
                dependency_8.atlas.hdmap.StopSign,
              ),
            );
            break;
          case 6:
            reader.readMessage(message.signal, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                6,
                dependency_6.atlas.hdmap.Signal.deserialize(reader),
                dependency_6.atlas.hdmap.Signal,
              ),
            );
            break;
          case 7:
            reader.readMessage(message.yield, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                7,
                dependency_9.atlas.hdmap.YieldSign.deserialize(reader),
                dependency_9.atlas.hdmap.YieldSign,
              ),
            );
            break;
          case 8:
            reader.readMessage(message.overlap, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                8,
                dependency_5.atlas.hdmap.Overlap.deserialize(reader),
                dependency_5.atlas.hdmap.Overlap,
              ),
            );
            break;
          case 9:
            reader.readMessage(message.clear_area, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                9,
                dependency_1.atlas.hdmap.ClearArea.deserialize(reader),
                dependency_1.atlas.hdmap.ClearArea,
              ),
            );
            break;
          case 10:
            reader.readMessage(message.speed_bump, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                10,
                dependency_7.atlas.hdmap.SpeedBump.deserialize(reader),
                dependency_7.atlas.hdmap.SpeedBump,
              ),
            );
            break;
          case 11:
            reader.readMessage(message.road, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                11,
                dependency_10.atlas.hdmap.Road.deserialize(reader),
                dependency_10.atlas.hdmap.Road,
              ),
            );
            break;
          case 12:
            reader.readMessage(message.parking_space, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                12,
                dependency_11.atlas.hdmap.ParkingSpace.deserialize(reader),
                dependency_11.atlas.hdmap.ParkingSpace,
              ),
            );
            break;
          case 13:
            reader.readMessage(message.pnc_junction, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                13,
                dependency_12.atlas.hdmap.PNCJunction.deserialize(reader),
                dependency_12.atlas.hdmap.PNCJunction,
              ),
            );
            break;
          case 14:
            reader.readMessage(message.rsu, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                14,
                dependency_13.atlas.hdmap.RSU.deserialize(reader),
                dependency_13.atlas.hdmap.RSU,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Map {
      return Map.deserialize(bytes);
    }
  }
}
