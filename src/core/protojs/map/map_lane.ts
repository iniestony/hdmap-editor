// This Source Code Form is subject to the terms of the Mozilla Public
// License, v2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.1
 * source: map/map_lane.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

import * as dependency_2 from "./map_geometry";
import * as dependency_1 from "./map_id";

export namespace atlas.hdmap {
  export class LaneBoundaryType extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            s?: number;
            types: LaneBoundaryType.Type[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("s" in data && data.s != undefined) {
          this.s = data.s;
        }
        this.types = data.types;
      }
    }
    get s() {
      return pb_1.Message.getField(this, 1) as number;
    }
    set s(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get types() {
      return pb_1.Message.getField(this, 2) as LaneBoundaryType.Type[];
    }
    set types(value: LaneBoundaryType.Type[]) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: { s?: number; types: LaneBoundaryType.Type[] }) {
      const message = new LaneBoundaryType({
        types: data.types,
      });
      if (data.s != null) {
        message.s = data.s;
      }
      return message;
    }
    toObject() {
      const data: {
        s?: number;
        types: LaneBoundaryType.Type[];
      } = {
        types: this.types,
      };
      if (this.s != null) {
        data.s = this.s;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.s !== undefined) {
        writer.writeDouble(1, this.s);
      }
      if (this.types !== undefined) {
        writer.writeRepeatedEnum(2, this.types);
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LaneBoundaryType {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new LaneBoundaryType();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            message.s = reader.readDouble();
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readEnum());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): LaneBoundaryType {
      return LaneBoundaryType.deserialize(bytes);
    }
  }
  export namespace LaneBoundaryType {
    export enum Type {
      UNKNOWN = 0,
      DOTTED_YELLOW = 1,
      DOTTED_WHITE = 2,
      SOLID_YELLOW = 3,
      SOLID_WHITE = 4,
      DOUBLE_YELLOW = 5,
      CURB = 6,
    }
  }
  export class LaneBoundary extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            curve?: dependency_2.atlas.hdmap.Curve;
            length?: number;
            virtual?: boolean;
            boundary_type: LaneBoundaryType[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("curve" in data && data.curve != undefined) {
          this.curve = data.curve;
        }
        if ("length" in data && data.length != undefined) {
          this.length = data.length;
        }
        if ("virtual" in data && data.virtual != undefined) {
          this.virtual = data.virtual;
        }
        this.boundary_type = data.boundary_type;
      }
    }
    get curve() {
      return pb_1.Message.getWrapperField(this, dependency_2.atlas.hdmap.Curve, 1);
    }
    set curve(value: dependency_2.atlas.hdmap.Curve) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get length() {
      return pb_1.Message.getField(this, 2) as number;
    }
    set length(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get virtual() {
      return pb_1.Message.getField(this, 3) as boolean;
    }
    set virtual(value: boolean) {
      pb_1.Message.setField(this, 3, value);
    }
    get boundary_type() {
      return pb_1.Message.getRepeatedWrapperField(this, LaneBoundaryType, 4);
    }
    set boundary_type(value: LaneBoundaryType[]) {
      pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    static fromObject(data: {
      curve?: ReturnType<typeof dependency_2.atlas.hdmap.Curve.prototype.toObject>;
      length?: number;
      virtual?: boolean;
      boundary_type: ReturnType<typeof LaneBoundaryType.prototype.toObject>[];
    }) {
      const message = new LaneBoundary({
        boundary_type: data.boundary_type.map((item) => LaneBoundaryType.fromObject(item)),
      });
      if (data.curve != null) {
        message.curve = dependency_2.atlas.hdmap.Curve.fromObject(data.curve);
      }
      if (data.length != null) {
        message.length = data.length;
      }
      if (data.virtual != null) {
        message.virtual = data.virtual;
      }
      return message;
    }
    toObject() {
      const data: {
        curve?: ReturnType<typeof dependency_2.atlas.hdmap.Curve.prototype.toObject>;
        length?: number;
        virtual?: boolean;
        boundary_type: ReturnType<typeof LaneBoundaryType.prototype.toObject>[];
      } = {
        boundary_type: this.boundary_type.map((item: LaneBoundaryType) => item.toObject()),
      };
      if (this.curve != null) {
        data.curve = this.curve.toObject();
      }
      if (this.length != null) {
        data.length = this.length;
      }
      if (this.virtual != null) {
        data.virtual = this.virtual;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.curve !== undefined) {
        writer.writeMessage(1, this.curve, () => this.curve.serialize(writer));
      }
      if (this.length !== undefined) {
        writer.writeDouble(2, this.length);
      }
      if (this.virtual !== undefined) {
        writer.writeBool(3, this.virtual);
      }
      if (this.boundary_type !== undefined) {
        writer.writeRepeatedMessage(4, this.boundary_type, (item: LaneBoundaryType) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LaneBoundary {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new LaneBoundary();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.curve,
              () => (message.curve = dependency_2.atlas.hdmap.Curve.deserialize(reader)),
            );
            break;
          case 2:
            message.length = reader.readDouble();
            break;
          case 3:
            message.virtual = reader.readBool();
            break;
          case 4:
            reader.readMessage(message.boundary_type, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                4,
                LaneBoundaryType.deserialize(reader),
                LaneBoundaryType,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): LaneBoundary {
      return LaneBoundary.deserialize(bytes);
    }
  }
  export class LaneSampleAssociation extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            s?: number;
            width?: number;
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("s" in data && data.s != undefined) {
          this.s = data.s;
        }
        if ("width" in data && data.width != undefined) {
          this.width = data.width;
        }
      }
    }
    get s() {
      return pb_1.Message.getField(this, 1) as number;
    }
    set s(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get width() {
      return pb_1.Message.getField(this, 2) as number;
    }
    set width(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: { s?: number; width?: number }) {
      const message = new LaneSampleAssociation({});
      if (data.s != null) {
        message.s = data.s;
      }
      if (data.width != null) {
        message.width = data.width;
      }
      return message;
    }
    toObject() {
      const data: {
        s?: number;
        width?: number;
      } = {};
      if (this.s != null) {
        data.s = this.s;
      }
      if (this.width != null) {
        data.width = this.width;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.s !== undefined) {
        writer.writeDouble(1, this.s);
      }
      if (this.width !== undefined) {
        writer.writeDouble(2, this.width);
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LaneSampleAssociation {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new LaneSampleAssociation();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            message.s = reader.readDouble();
            break;
          case 2:
            message.width = reader.readDouble();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): LaneSampleAssociation {
      return LaneSampleAssociation.deserialize(bytes);
    }
  }
  export class Lane extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            id?: dependency_1.atlas.hdmap.Id;
            central_curve?: dependency_2.atlas.hdmap.Curve;
            left_boundary?: LaneBoundary;
            right_boundary?: LaneBoundary;
            length?: number;
            speed_limit?: number;
            overlap_id: dependency_1.atlas.hdmap.Id[];
            predecessor_id: dependency_1.atlas.hdmap.Id[];
            successor_id: dependency_1.atlas.hdmap.Id[];
            left_neighbor_forward_lane_id: dependency_1.atlas.hdmap.Id[];
            right_neighbor_forward_lane_id: dependency_1.atlas.hdmap.Id[];
            type?: Lane.LaneType;
            turn?: Lane.LaneTurn;
            left_neighbor_reverse_lane_id: dependency_1.atlas.hdmap.Id[];
            right_neighbor_reverse_lane_id: dependency_1.atlas.hdmap.Id[];
            junction_id?: dependency_1.atlas.hdmap.Id;
            left_sample: LaneSampleAssociation[];
            right_sample: LaneSampleAssociation[];
            direction?: Lane.LaneDirection;
            left_road_sample: LaneSampleAssociation[];
            right_road_sample: LaneSampleAssociation[];
            self_reverse_lane_id: dependency_1.atlas.hdmap.Id[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [7, 8, 9, 10, 11, 14, 15, 17, 18, 20, 21, 22],
        [],
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("id" in data && data.id != undefined) {
          this.id = data.id;
        }
        if ("central_curve" in data && data.central_curve != undefined) {
          this.central_curve = data.central_curve;
        }
        if ("left_boundary" in data && data.left_boundary != undefined) {
          this.left_boundary = data.left_boundary;
        }
        if ("right_boundary" in data && data.right_boundary != undefined) {
          this.right_boundary = data.right_boundary;
        }
        if ("length" in data && data.length != undefined) {
          this.length = data.length;
        }
        if ("speed_limit" in data && data.speed_limit != undefined) {
          this.speed_limit = data.speed_limit;
        }
        this.overlap_id = data.overlap_id;
        this.predecessor_id = data.predecessor_id;
        this.successor_id = data.successor_id;
        this.left_neighbor_forward_lane_id = data.left_neighbor_forward_lane_id;
        this.right_neighbor_forward_lane_id = data.right_neighbor_forward_lane_id;
        if ("type" in data && data.type != undefined) {
          this.type = data.type;
        }
        if ("turn" in data && data.turn != undefined) {
          this.turn = data.turn;
        }
        this.left_neighbor_reverse_lane_id = data.left_neighbor_reverse_lane_id;
        this.right_neighbor_reverse_lane_id = data.right_neighbor_reverse_lane_id;
        if ("junction_id" in data && data.junction_id != undefined) {
          this.junction_id = data.junction_id;
        }
        this.left_sample = data.left_sample;
        this.right_sample = data.right_sample;
        if ("direction" in data && data.direction != undefined) {
          this.direction = data.direction;
        }
        this.left_road_sample = data.left_road_sample;
        this.right_road_sample = data.right_road_sample;
        this.self_reverse_lane_id = data.self_reverse_lane_id;
      }
    }
    get id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 1);
    }
    set id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get central_curve() {
      return pb_1.Message.getWrapperField(this, dependency_2.atlas.hdmap.Curve, 2);
    }
    set central_curve(value: dependency_2.atlas.hdmap.Curve) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get left_boundary() {
      return pb_1.Message.getWrapperField(this, LaneBoundary, 3);
    }
    set left_boundary(value: LaneBoundary) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get right_boundary() {
      return pb_1.Message.getWrapperField(this, LaneBoundary, 4);
    }
    set right_boundary(value: LaneBoundary) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get length() {
      return pb_1.Message.getField(this, 5) as number;
    }
    set length(value: number) {
      pb_1.Message.setField(this, 5, value);
    }
    get speed_limit() {
      return pb_1.Message.getField(this, 6) as number;
    }
    set speed_limit(value: number) {
      pb_1.Message.setField(this, 6, value);
    }
    get overlap_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 7);
    }
    set overlap_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    get predecessor_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 8);
    }
    set predecessor_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 8, value);
    }
    get successor_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 9);
    }
    set successor_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 9, value);
    }
    get left_neighbor_forward_lane_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 10);
    }
    set left_neighbor_forward_lane_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 10, value);
    }
    get right_neighbor_forward_lane_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 11);
    }
    set right_neighbor_forward_lane_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 11, value);
    }
    get type() {
      return pb_1.Message.getField(this, 12) as Lane.LaneType;
    }
    set type(value: Lane.LaneType) {
      pb_1.Message.setField(this, 12, value);
    }
    get turn() {
      return pb_1.Message.getField(this, 13) as Lane.LaneTurn;
    }
    set turn(value: Lane.LaneTurn) {
      pb_1.Message.setField(this, 13, value);
    }
    get left_neighbor_reverse_lane_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 14);
    }
    set left_neighbor_reverse_lane_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 14, value);
    }
    get right_neighbor_reverse_lane_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 15);
    }
    set right_neighbor_reverse_lane_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 15, value);
    }
    get junction_id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 16);
    }
    set junction_id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 16, value);
    }
    get left_sample() {
      return pb_1.Message.getRepeatedWrapperField(this, LaneSampleAssociation, 17);
    }
    set left_sample(value: LaneSampleAssociation[]) {
      pb_1.Message.setRepeatedWrapperField(this, 17, value);
    }
    get right_sample() {
      return pb_1.Message.getRepeatedWrapperField(this, LaneSampleAssociation, 18);
    }
    set right_sample(value: LaneSampleAssociation[]) {
      pb_1.Message.setRepeatedWrapperField(this, 18, value);
    }
    get direction() {
      return pb_1.Message.getField(this, 19) as Lane.LaneDirection;
    }
    set direction(value: Lane.LaneDirection) {
      pb_1.Message.setField(this, 19, value);
    }
    get left_road_sample() {
      return pb_1.Message.getRepeatedWrapperField(this, LaneSampleAssociation, 20);
    }
    set left_road_sample(value: LaneSampleAssociation[]) {
      pb_1.Message.setRepeatedWrapperField(this, 20, value);
    }
    get right_road_sample() {
      return pb_1.Message.getRepeatedWrapperField(this, LaneSampleAssociation, 21);
    }
    set right_road_sample(value: LaneSampleAssociation[]) {
      pb_1.Message.setRepeatedWrapperField(this, 21, value);
    }
    get self_reverse_lane_id() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.hdmap.Id, 22);
    }
    set self_reverse_lane_id(value: dependency_1.atlas.hdmap.Id[]) {
      pb_1.Message.setRepeatedWrapperField(this, 22, value);
    }
    static fromObject(data: {
      id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      central_curve?: ReturnType<typeof dependency_2.atlas.hdmap.Curve.prototype.toObject>;
      left_boundary?: ReturnType<typeof LaneBoundary.prototype.toObject>;
      right_boundary?: ReturnType<typeof LaneBoundary.prototype.toObject>;
      length?: number;
      speed_limit?: number;
      overlap_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
      predecessor_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
      successor_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
      left_neighbor_forward_lane_id: ReturnType<
        typeof dependency_1.atlas.hdmap.Id.prototype.toObject
      >[];
      right_neighbor_forward_lane_id: ReturnType<
        typeof dependency_1.atlas.hdmap.Id.prototype.toObject
      >[];
      type?: Lane.LaneType;
      turn?: Lane.LaneTurn;
      left_neighbor_reverse_lane_id: ReturnType<
        typeof dependency_1.atlas.hdmap.Id.prototype.toObject
      >[];
      right_neighbor_reverse_lane_id: ReturnType<
        typeof dependency_1.atlas.hdmap.Id.prototype.toObject
      >[];
      junction_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      left_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
      right_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
      direction?: Lane.LaneDirection;
      left_road_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
      right_road_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
      self_reverse_lane_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
    }) {
      const message = new Lane({
        overlap_id: data.overlap_id.map((item) => dependency_1.atlas.hdmap.Id.fromObject(item)),
        predecessor_id: data.predecessor_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
        successor_id: data.successor_id.map((item) => dependency_1.atlas.hdmap.Id.fromObject(item)),
        left_neighbor_forward_lane_id: data.left_neighbor_forward_lane_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
        right_neighbor_forward_lane_id: data.right_neighbor_forward_lane_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
        left_neighbor_reverse_lane_id: data.left_neighbor_reverse_lane_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
        right_neighbor_reverse_lane_id: data.right_neighbor_reverse_lane_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
        left_sample: data.left_sample.map((item) => LaneSampleAssociation.fromObject(item)),
        right_sample: data.right_sample.map((item) => LaneSampleAssociation.fromObject(item)),
        left_road_sample: data.left_road_sample.map((item) =>
          LaneSampleAssociation.fromObject(item),
        ),
        right_road_sample: data.right_road_sample.map((item) =>
          LaneSampleAssociation.fromObject(item),
        ),
        self_reverse_lane_id: data.self_reverse_lane_id.map((item) =>
          dependency_1.atlas.hdmap.Id.fromObject(item),
        ),
      });
      if (data.id != null) {
        message.id = dependency_1.atlas.hdmap.Id.fromObject(data.id);
      }
      if (data.central_curve != null) {
        message.central_curve = dependency_2.atlas.hdmap.Curve.fromObject(data.central_curve);
      }
      if (data.left_boundary != null) {
        message.left_boundary = LaneBoundary.fromObject(data.left_boundary);
      }
      if (data.right_boundary != null) {
        message.right_boundary = LaneBoundary.fromObject(data.right_boundary);
      }
      if (data.length != null) {
        message.length = data.length;
      }
      if (data.speed_limit != null) {
        message.speed_limit = data.speed_limit;
      }
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.turn != null) {
        message.turn = data.turn;
      }
      if (data.junction_id != null) {
        message.junction_id = dependency_1.atlas.hdmap.Id.fromObject(data.junction_id);
      }
      if (data.direction != null) {
        message.direction = data.direction;
      }
      return message;
    }
    toObject() {
      const data: {
        id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
        central_curve?: ReturnType<typeof dependency_2.atlas.hdmap.Curve.prototype.toObject>;
        left_boundary?: ReturnType<typeof LaneBoundary.prototype.toObject>;
        right_boundary?: ReturnType<typeof LaneBoundary.prototype.toObject>;
        length?: number;
        speed_limit?: number;
        overlap_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
        predecessor_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
        successor_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
        left_neighbor_forward_lane_id: ReturnType<
          typeof dependency_1.atlas.hdmap.Id.prototype.toObject
        >[];
        right_neighbor_forward_lane_id: ReturnType<
          typeof dependency_1.atlas.hdmap.Id.prototype.toObject
        >[];
        type?: Lane.LaneType;
        turn?: Lane.LaneTurn;
        left_neighbor_reverse_lane_id: ReturnType<
          typeof dependency_1.atlas.hdmap.Id.prototype.toObject
        >[];
        right_neighbor_reverse_lane_id: ReturnType<
          typeof dependency_1.atlas.hdmap.Id.prototype.toObject
        >[];
        junction_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
        left_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
        right_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
        direction?: Lane.LaneDirection;
        left_road_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
        right_road_sample: ReturnType<typeof LaneSampleAssociation.prototype.toObject>[];
        self_reverse_lane_id: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>[];
      } = {
        overlap_id: this.overlap_id.map((item: dependency_1.atlas.hdmap.Id) => item.toObject()),
        predecessor_id: this.predecessor_id.map((item: dependency_1.atlas.hdmap.Id) =>
          item.toObject(),
        ),
        successor_id: this.successor_id.map((item: dependency_1.atlas.hdmap.Id) => item.toObject()),
        left_neighbor_forward_lane_id: this.left_neighbor_forward_lane_id.map(
          (item: dependency_1.atlas.hdmap.Id) => item.toObject(),
        ),
        right_neighbor_forward_lane_id: this.right_neighbor_forward_lane_id.map(
          (item: dependency_1.atlas.hdmap.Id) => item.toObject(),
        ),
        left_neighbor_reverse_lane_id: this.left_neighbor_reverse_lane_id.map(
          (item: dependency_1.atlas.hdmap.Id) => item.toObject(),
        ),
        right_neighbor_reverse_lane_id: this.right_neighbor_reverse_lane_id.map(
          (item: dependency_1.atlas.hdmap.Id) => item.toObject(),
        ),
        left_sample: this.left_sample.map((item: LaneSampleAssociation) => item.toObject()),
        right_sample: this.right_sample.map((item: LaneSampleAssociation) => item.toObject()),
        left_road_sample: this.left_road_sample.map((item: LaneSampleAssociation) =>
          item.toObject(),
        ),
        right_road_sample: this.right_road_sample.map((item: LaneSampleAssociation) =>
          item.toObject(),
        ),
        self_reverse_lane_id: this.self_reverse_lane_id.map((item: dependency_1.atlas.hdmap.Id) =>
          item.toObject(),
        ),
      };
      if (this.id != null) {
        data.id = this.id.toObject();
      }
      if (this.central_curve != null) {
        data.central_curve = this.central_curve.toObject();
      }
      if (this.left_boundary != null) {
        data.left_boundary = this.left_boundary.toObject();
      }
      if (this.right_boundary != null) {
        data.right_boundary = this.right_boundary.toObject();
      }
      if (this.length != null) {
        data.length = this.length;
      }
      if (this.speed_limit != null) {
        data.speed_limit = this.speed_limit;
      }
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.turn != null) {
        data.turn = this.turn;
      }
      if (this.junction_id != null) {
        data.junction_id = this.junction_id.toObject();
      }
      if (this.direction != null) {
        data.direction = this.direction;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id !== undefined) {
        writer.writeMessage(1, this.id, () => this.id.serialize(writer));
      }
      if (this.central_curve !== undefined) {
        writer.writeMessage(2, this.central_curve, () => this.central_curve.serialize(writer));
      }
      if (this.left_boundary !== undefined) {
        writer.writeMessage(3, this.left_boundary, () => this.left_boundary.serialize(writer));
      }
      if (this.right_boundary !== undefined) {
        writer.writeMessage(4, this.right_boundary, () => this.right_boundary.serialize(writer));
      }
      if (this.length !== undefined) {
        writer.writeDouble(5, this.length);
      }
      if (this.speed_limit !== undefined) {
        writer.writeDouble(6, this.speed_limit);
      }
      if (this.overlap_id !== undefined) {
        writer.writeRepeatedMessage(7, this.overlap_id, (item: dependency_1.atlas.hdmap.Id) =>
          item.serialize(writer),
        );
      }
      if (this.predecessor_id !== undefined) {
        writer.writeRepeatedMessage(8, this.predecessor_id, (item: dependency_1.atlas.hdmap.Id) =>
          item.serialize(writer),
        );
      }
      if (this.successor_id !== undefined) {
        writer.writeRepeatedMessage(9, this.successor_id, (item: dependency_1.atlas.hdmap.Id) =>
          item.serialize(writer),
        );
      }
      if (this.left_neighbor_forward_lane_id !== undefined) {
        writer.writeRepeatedMessage(
          10,
          this.left_neighbor_forward_lane_id,
          (item: dependency_1.atlas.hdmap.Id) => item.serialize(writer),
        );
      }
      if (this.right_neighbor_forward_lane_id !== undefined) {
        writer.writeRepeatedMessage(
          11,
          this.right_neighbor_forward_lane_id,
          (item: dependency_1.atlas.hdmap.Id) => item.serialize(writer),
        );
      }
      if (this.type !== undefined) {
        writer.writeEnum(12, this.type);
      }
      if (this.turn !== undefined) {
        writer.writeEnum(13, this.turn);
      }
      if (this.left_neighbor_reverse_lane_id !== undefined) {
        writer.writeRepeatedMessage(
          14,
          this.left_neighbor_reverse_lane_id,
          (item: dependency_1.atlas.hdmap.Id) => item.serialize(writer),
        );
      }
      if (this.right_neighbor_reverse_lane_id !== undefined) {
        writer.writeRepeatedMessage(
          15,
          this.right_neighbor_reverse_lane_id,
          (item: dependency_1.atlas.hdmap.Id) => item.serialize(writer),
        );
      }
      if (this.junction_id !== undefined) {
        writer.writeMessage(16, this.junction_id, () => this.junction_id.serialize(writer));
      }
      if (this.left_sample !== undefined) {
        writer.writeRepeatedMessage(17, this.left_sample, (item: LaneSampleAssociation) =>
          item.serialize(writer),
        );
      }
      if (this.right_sample !== undefined) {
        writer.writeRepeatedMessage(18, this.right_sample, (item: LaneSampleAssociation) =>
          item.serialize(writer),
        );
      }
      if (this.direction !== undefined) {
        writer.writeEnum(19, this.direction);
      }
      if (this.left_road_sample !== undefined) {
        writer.writeRepeatedMessage(20, this.left_road_sample, (item: LaneSampleAssociation) =>
          item.serialize(writer),
        );
      }
      if (this.right_road_sample !== undefined) {
        writer.writeRepeatedMessage(21, this.right_road_sample, (item: LaneSampleAssociation) =>
          item.serialize(writer),
        );
      }
      if (this.self_reverse_lane_id !== undefined) {
        writer.writeRepeatedMessage(
          22,
          this.self_reverse_lane_id,
          (item: dependency_1.atlas.hdmap.Id) => item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Lane {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Lane();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.id,
              () => (message.id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.central_curve,
              () => (message.central_curve = dependency_2.atlas.hdmap.Curve.deserialize(reader)),
            );
            break;
          case 3:
            reader.readMessage(
              message.left_boundary,
              () => (message.left_boundary = LaneBoundary.deserialize(reader)),
            );
            break;
          case 4:
            reader.readMessage(
              message.right_boundary,
              () => (message.right_boundary = LaneBoundary.deserialize(reader)),
            );
            break;
          case 5:
            message.length = reader.readDouble();
            break;
          case 6:
            message.speed_limit = reader.readDouble();
            break;
          case 7:
            reader.readMessage(message.overlap_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                7,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 8:
            reader.readMessage(message.predecessor_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                8,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 9:
            reader.readMessage(message.successor_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                9,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 10:
            reader.readMessage(message.left_neighbor_forward_lane_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                10,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 11:
            reader.readMessage(message.right_neighbor_forward_lane_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                11,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 12:
            message.type = reader.readEnum();
            break;
          case 13:
            message.turn = reader.readEnum();
            break;
          case 14:
            reader.readMessage(message.left_neighbor_reverse_lane_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                14,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 15:
            reader.readMessage(message.right_neighbor_reverse_lane_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                15,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          case 16:
            reader.readMessage(
              message.junction_id,
              () => (message.junction_id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          case 17:
            reader.readMessage(message.left_sample, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                17,
                LaneSampleAssociation.deserialize(reader),
                LaneSampleAssociation,
              ),
            );
            break;
          case 18:
            reader.readMessage(message.right_sample, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                18,
                LaneSampleAssociation.deserialize(reader),
                LaneSampleAssociation,
              ),
            );
            break;
          case 19:
            message.direction = reader.readEnum();
            break;
          case 20:
            reader.readMessage(message.left_road_sample, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                20,
                LaneSampleAssociation.deserialize(reader),
                LaneSampleAssociation,
              ),
            );
            break;
          case 21:
            reader.readMessage(message.right_road_sample, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                21,
                LaneSampleAssociation.deserialize(reader),
                LaneSampleAssociation,
              ),
            );
            break;
          case 22:
            reader.readMessage(message.self_reverse_lane_id, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                22,
                dependency_1.atlas.hdmap.Id.deserialize(reader),
                dependency_1.atlas.hdmap.Id,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Lane {
      return Lane.deserialize(bytes);
    }
  }
  export namespace Lane {
    export enum LaneType {
      NONE = 1,
      CITY_DRIVING = 2,
      BIKING = 3,
      SIDEWALK = 4,
      PARKING = 5,
      SHOULDER = 6,
    }
    export enum LaneTurn {
      NO_TURN = 1,
      LEFT_TURN = 2,
      RIGHT_TURN = 3,
      U_TURN = 4,
    }
    export enum LaneDirection {
      FORWARD = 1,
      BACKWARD = 2,
      BIDIRECTION = 3,
    }
  }
}
