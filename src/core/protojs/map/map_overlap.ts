// This Source Code Form is subject to the terms of the Mozilla Public
// License, v2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.1
 * source: map/map_overlap.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

import * as dependency_2 from "./map_geometry";
import * as dependency_1 from "./map_id";

export namespace atlas.hdmap {
  export class LaneOverlapInfo extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            start_s?: number;
            end_s?: number;
            is_merge?: boolean;
            region_overlap_id?: dependency_1.atlas.hdmap.Id;
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("start_s" in data && data.start_s != undefined) {
          this.start_s = data.start_s;
        }
        if ("end_s" in data && data.end_s != undefined) {
          this.end_s = data.end_s;
        }
        if ("is_merge" in data && data.is_merge != undefined) {
          this.is_merge = data.is_merge;
        }
        if ("region_overlap_id" in data && data.region_overlap_id != undefined) {
          this.region_overlap_id = data.region_overlap_id;
        }
      }
    }
    get start_s() {
      return pb_1.Message.getField(this, 1) as number;
    }
    set start_s(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get end_s() {
      return pb_1.Message.getField(this, 2) as number;
    }
    set end_s(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get is_merge() {
      return pb_1.Message.getField(this, 3) as boolean;
    }
    set is_merge(value: boolean) {
      pb_1.Message.setField(this, 3, value);
    }
    get region_overlap_id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 4);
    }
    set region_overlap_id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    static fromObject(data: {
      start_s?: number;
      end_s?: number;
      is_merge?: boolean;
      region_overlap_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
    }) {
      const message = new LaneOverlapInfo({});
      if (data.start_s != null) {
        message.start_s = data.start_s;
      }
      if (data.end_s != null) {
        message.end_s = data.end_s;
      }
      if (data.is_merge != null) {
        message.is_merge = data.is_merge;
      }
      if (data.region_overlap_id != null) {
        message.region_overlap_id = dependency_1.atlas.hdmap.Id.fromObject(data.region_overlap_id);
      }
      return message;
    }
    toObject() {
      const data: {
        start_s?: number;
        end_s?: number;
        is_merge?: boolean;
        region_overlap_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      } = {};
      if (this.start_s != null) {
        data.start_s = this.start_s;
      }
      if (this.end_s != null) {
        data.end_s = this.end_s;
      }
      if (this.is_merge != null) {
        data.is_merge = this.is_merge;
      }
      if (this.region_overlap_id != null) {
        data.region_overlap_id = this.region_overlap_id.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.start_s !== undefined) {
        writer.writeDouble(1, this.start_s);
      }
      if (this.end_s !== undefined) {
        writer.writeDouble(2, this.end_s);
      }
      if (this.is_merge !== undefined) {
        writer.writeBool(3, this.is_merge);
      }
      if (this.region_overlap_id !== undefined) {
        writer.writeMessage(4, this.region_overlap_id, () =>
          this.region_overlap_id.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LaneOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new LaneOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            message.start_s = reader.readDouble();
            break;
          case 2:
            message.end_s = reader.readDouble();
            break;
          case 3:
            message.is_merge = reader.readBool();
            break;
          case 4:
            reader.readMessage(
              message.region_overlap_id,
              () => (message.region_overlap_id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): LaneOverlapInfo {
      return LaneOverlapInfo.deserialize(bytes);
    }
  }
  export class SignalOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new SignalOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignalOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new SignalOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): SignalOverlapInfo {
      return SignalOverlapInfo.deserialize(bytes);
    }
  }
  export class StopSignOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new StopSignOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StopSignOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new StopSignOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): StopSignOverlapInfo {
      return StopSignOverlapInfo.deserialize(bytes);
    }
  }
  export class CrosswalkOverlapInfo extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            region_overlap_id?: dependency_1.atlas.hdmap.Id;
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("region_overlap_id" in data && data.region_overlap_id != undefined) {
          this.region_overlap_id = data.region_overlap_id;
        }
      }
    }
    get region_overlap_id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 1);
    }
    set region_overlap_id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    static fromObject(data: {
      region_overlap_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
    }) {
      const message = new CrosswalkOverlapInfo({});
      if (data.region_overlap_id != null) {
        message.region_overlap_id = dependency_1.atlas.hdmap.Id.fromObject(data.region_overlap_id);
      }
      return message;
    }
    toObject() {
      const data: {
        region_overlap_id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      } = {};
      if (this.region_overlap_id != null) {
        data.region_overlap_id = this.region_overlap_id.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.region_overlap_id !== undefined) {
        writer.writeMessage(1, this.region_overlap_id, () =>
          this.region_overlap_id.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CrosswalkOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new CrosswalkOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.region_overlap_id,
              () => (message.region_overlap_id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): CrosswalkOverlapInfo {
      return CrosswalkOverlapInfo.deserialize(bytes);
    }
  }
  export class JunctionOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new JunctionOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JunctionOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new JunctionOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): JunctionOverlapInfo {
      return JunctionOverlapInfo.deserialize(bytes);
    }
  }
  export class YieldOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new YieldOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YieldOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new YieldOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): YieldOverlapInfo {
      return YieldOverlapInfo.deserialize(bytes);
    }
  }
  export class ClearAreaOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new ClearAreaOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClearAreaOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ClearAreaOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): ClearAreaOverlapInfo {
      return ClearAreaOverlapInfo.deserialize(bytes);
    }
  }
  export class SpeedBumpOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new SpeedBumpOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SpeedBumpOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new SpeedBumpOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): SpeedBumpOverlapInfo {
      return SpeedBumpOverlapInfo.deserialize(bytes);
    }
  }
  export class ParkingSpaceOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new ParkingSpaceOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ParkingSpaceOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ParkingSpaceOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): ParkingSpaceOverlapInfo {
      return ParkingSpaceOverlapInfo.deserialize(bytes);
    }
  }
  export class PNCJunctionOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new PNCJunctionOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PNCJunctionOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new PNCJunctionOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): PNCJunctionOverlapInfo {
      return PNCJunctionOverlapInfo.deserialize(bytes);
    }
  }
  export class RSUOverlapInfo extends pb_1.Message {
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(_data: {}) {
      const message = new RSUOverlapInfo({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RSUOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RSUOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): RSUOverlapInfo {
      return RSUOverlapInfo.deserialize(bytes);
    }
  }
  export class RegionOverlapInfo extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            id?: dependency_1.atlas.hdmap.Id;
            polygon: dependency_2.atlas.hdmap.Polygon[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("id" in data && data.id != undefined) {
          this.id = data.id;
        }
        this.polygon = data.polygon;
      }
    }
    get id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 1);
    }
    set id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get polygon() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_2.atlas.hdmap.Polygon, 2);
    }
    set polygon(value: dependency_2.atlas.hdmap.Polygon[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      polygon: ReturnType<typeof dependency_2.atlas.hdmap.Polygon.prototype.toObject>[];
    }) {
      const message = new RegionOverlapInfo({
        polygon: data.polygon.map((item) => dependency_2.atlas.hdmap.Polygon.fromObject(item)),
      });
      if (data.id != null) {
        message.id = dependency_1.atlas.hdmap.Id.fromObject(data.id);
      }
      return message;
    }
    toObject() {
      const data: {
        id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
        polygon: ReturnType<typeof dependency_2.atlas.hdmap.Polygon.prototype.toObject>[];
      } = {
        polygon: this.polygon.map((item: dependency_2.atlas.hdmap.Polygon) => item.toObject()),
      };
      if (this.id != null) {
        data.id = this.id.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id !== undefined) {
        writer.writeMessage(1, this.id, () => this.id.serialize(writer));
      }
      if (this.polygon !== undefined) {
        writer.writeRepeatedMessage(2, this.polygon, (item: dependency_2.atlas.hdmap.Polygon) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RegionOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RegionOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.id,
              () => (message.id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(message.polygon, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                dependency_2.atlas.hdmap.Polygon.deserialize(reader),
                dependency_2.atlas.hdmap.Polygon,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): RegionOverlapInfo {
      return RegionOverlapInfo.deserialize(bytes);
    }
  }
  export class ObjectOverlapInfo extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | ({
            id?: dependency_1.atlas.hdmap.Id;
          } & (
            | {
                lane_overlap_info?: LaneOverlapInfo;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: SignalOverlapInfo;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: StopSignOverlapInfo;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: CrosswalkOverlapInfo;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: JunctionOverlapInfo;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: YieldOverlapInfo;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: ClearAreaOverlapInfo;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: SpeedBumpOverlapInfo;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: ParkingSpaceOverlapInfo;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: PNCJunctionOverlapInfo;
                rsu_overlap_info?: never;
              }
            | {
                lane_overlap_info?: never;
                signal_overlap_info?: never;
                stop_sign_overlap_info?: never;
                crosswalk_overlap_info?: never;
                junction_overlap_info?: never;
                yield_sign_overlap_info?: never;
                clear_area_overlap_info?: never;
                speed_bump_overlap_info?: never;
                parking_space_overlap_info?: never;
                pnc_junction_overlap_info?: never;
                rsu_overlap_info?: RSUOverlapInfo;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        [[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]],
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("id" in data && data.id != undefined) {
          this.id = data.id;
        }
        if ("lane_overlap_info" in data && data.lane_overlap_info != undefined) {
          this.lane_overlap_info = data.lane_overlap_info;
        }
        if ("signal_overlap_info" in data && data.signal_overlap_info != undefined) {
          this.signal_overlap_info = data.signal_overlap_info;
        }
        if ("stop_sign_overlap_info" in data && data.stop_sign_overlap_info != undefined) {
          this.stop_sign_overlap_info = data.stop_sign_overlap_info;
        }
        if ("crosswalk_overlap_info" in data && data.crosswalk_overlap_info != undefined) {
          this.crosswalk_overlap_info = data.crosswalk_overlap_info;
        }
        if ("junction_overlap_info" in data && data.junction_overlap_info != undefined) {
          this.junction_overlap_info = data.junction_overlap_info;
        }
        if ("yield_sign_overlap_info" in data && data.yield_sign_overlap_info != undefined) {
          this.yield_sign_overlap_info = data.yield_sign_overlap_info;
        }
        if ("clear_area_overlap_info" in data && data.clear_area_overlap_info != undefined) {
          this.clear_area_overlap_info = data.clear_area_overlap_info;
        }
        if ("speed_bump_overlap_info" in data && data.speed_bump_overlap_info != undefined) {
          this.speed_bump_overlap_info = data.speed_bump_overlap_info;
        }
        if ("parking_space_overlap_info" in data && data.parking_space_overlap_info != undefined) {
          this.parking_space_overlap_info = data.parking_space_overlap_info;
        }
        if ("pnc_junction_overlap_info" in data && data.pnc_junction_overlap_info != undefined) {
          this.pnc_junction_overlap_info = data.pnc_junction_overlap_info;
        }
        if ("rsu_overlap_info" in data && data.rsu_overlap_info != undefined) {
          this.rsu_overlap_info = data.rsu_overlap_info;
        }
      }
    }
    get id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 1);
    }
    set id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get lane_overlap_info() {
      return pb_1.Message.getWrapperField(this, LaneOverlapInfo, 3);
    }
    set lane_overlap_info(value: LaneOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 3, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get signal_overlap_info() {
      return pb_1.Message.getWrapperField(this, SignalOverlapInfo, 4);
    }
    set signal_overlap_info(value: SignalOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 4, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get stop_sign_overlap_info() {
      return pb_1.Message.getWrapperField(this, StopSignOverlapInfo, 5);
    }
    set stop_sign_overlap_info(value: StopSignOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 5, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get crosswalk_overlap_info() {
      return pb_1.Message.getWrapperField(this, CrosswalkOverlapInfo, 6);
    }
    set crosswalk_overlap_info(value: CrosswalkOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 6, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get junction_overlap_info() {
      return pb_1.Message.getWrapperField(this, JunctionOverlapInfo, 7);
    }
    set junction_overlap_info(value: JunctionOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 7, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get yield_sign_overlap_info() {
      return pb_1.Message.getWrapperField(this, YieldOverlapInfo, 8);
    }
    set yield_sign_overlap_info(value: YieldOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 8, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get clear_area_overlap_info() {
      return pb_1.Message.getWrapperField(this, ClearAreaOverlapInfo, 9);
    }
    set clear_area_overlap_info(value: ClearAreaOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 9, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get speed_bump_overlap_info() {
      return pb_1.Message.getWrapperField(this, SpeedBumpOverlapInfo, 10);
    }
    set speed_bump_overlap_info(value: SpeedBumpOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 10, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get parking_space_overlap_info() {
      return pb_1.Message.getWrapperField(this, ParkingSpaceOverlapInfo, 11);
    }
    set parking_space_overlap_info(value: ParkingSpaceOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 11, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get pnc_junction_overlap_info() {
      return pb_1.Message.getWrapperField(this, PNCJunctionOverlapInfo, 12);
    }
    set pnc_junction_overlap_info(value: PNCJunctionOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 12, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get rsu_overlap_info() {
      return pb_1.Message.getWrapperField(this, RSUOverlapInfo, 13);
    }
    set rsu_overlap_info(value: RSUOverlapInfo) {
      pb_1.Message.setOneofWrapperField(this, 13, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], value);
    }
    get overlap_info() {
      const cases: {
        [index: number]:
          | "none"
          | "lane_overlap_info"
          | "signal_overlap_info"
          | "stop_sign_overlap_info"
          | "crosswalk_overlap_info"
          | "junction_overlap_info"
          | "yield_sign_overlap_info"
          | "clear_area_overlap_info"
          | "speed_bump_overlap_info"
          | "parking_space_overlap_info"
          | "pnc_junction_overlap_info"
          | "rsu_overlap_info";
      } = {
        0: "none",
        3: "lane_overlap_info",
        4: "signal_overlap_info",
        5: "stop_sign_overlap_info",
        6: "crosswalk_overlap_info",
        7: "junction_overlap_info",
        8: "yield_sign_overlap_info",
        9: "clear_area_overlap_info",
        10: "speed_bump_overlap_info",
        11: "parking_space_overlap_info",
        12: "pnc_junction_overlap_info",
        13: "rsu_overlap_info",
      };
      return cases[pb_1.Message.computeOneofCase(this, [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])];
    }
    static fromObject(data: {
      id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      lane_overlap_info?: ReturnType<typeof LaneOverlapInfo.prototype.toObject>;
      signal_overlap_info?: ReturnType<typeof SignalOverlapInfo.prototype.toObject>;
      stop_sign_overlap_info?: ReturnType<typeof StopSignOverlapInfo.prototype.toObject>;
      crosswalk_overlap_info?: ReturnType<typeof CrosswalkOverlapInfo.prototype.toObject>;
      junction_overlap_info?: ReturnType<typeof JunctionOverlapInfo.prototype.toObject>;
      yield_sign_overlap_info?: ReturnType<typeof YieldOverlapInfo.prototype.toObject>;
      clear_area_overlap_info?: ReturnType<typeof ClearAreaOverlapInfo.prototype.toObject>;
      speed_bump_overlap_info?: ReturnType<typeof SpeedBumpOverlapInfo.prototype.toObject>;
      parking_space_overlap_info?: ReturnType<typeof ParkingSpaceOverlapInfo.prototype.toObject>;
      pnc_junction_overlap_info?: ReturnType<typeof PNCJunctionOverlapInfo.prototype.toObject>;
      rsu_overlap_info?: ReturnType<typeof RSUOverlapInfo.prototype.toObject>;
    }) {
      const message = new ObjectOverlapInfo({});
      if (data.id != null) {
        message.id = dependency_1.atlas.hdmap.Id.fromObject(data.id);
      }
      if (data.lane_overlap_info != null) {
        message.lane_overlap_info = LaneOverlapInfo.fromObject(data.lane_overlap_info);
      }
      if (data.signal_overlap_info != null) {
        message.signal_overlap_info = SignalOverlapInfo.fromObject(data.signal_overlap_info);
      }
      if (data.stop_sign_overlap_info != null) {
        message.stop_sign_overlap_info = StopSignOverlapInfo.fromObject(
          data.stop_sign_overlap_info,
        );
      }
      if (data.crosswalk_overlap_info != null) {
        message.crosswalk_overlap_info = CrosswalkOverlapInfo.fromObject(
          data.crosswalk_overlap_info,
        );
      }
      if (data.junction_overlap_info != null) {
        message.junction_overlap_info = JunctionOverlapInfo.fromObject(data.junction_overlap_info);
      }
      if (data.yield_sign_overlap_info != null) {
        message.yield_sign_overlap_info = YieldOverlapInfo.fromObject(data.yield_sign_overlap_info);
      }
      if (data.clear_area_overlap_info != null) {
        message.clear_area_overlap_info = ClearAreaOverlapInfo.fromObject(
          data.clear_area_overlap_info,
        );
      }
      if (data.speed_bump_overlap_info != null) {
        message.speed_bump_overlap_info = SpeedBumpOverlapInfo.fromObject(
          data.speed_bump_overlap_info,
        );
      }
      if (data.parking_space_overlap_info != null) {
        message.parking_space_overlap_info = ParkingSpaceOverlapInfo.fromObject(
          data.parking_space_overlap_info,
        );
      }
      if (data.pnc_junction_overlap_info != null) {
        message.pnc_junction_overlap_info = PNCJunctionOverlapInfo.fromObject(
          data.pnc_junction_overlap_info,
        );
      }
      if (data.rsu_overlap_info != null) {
        message.rsu_overlap_info = RSUOverlapInfo.fromObject(data.rsu_overlap_info);
      }
      return message;
    }
    toObject() {
      const data: {
        id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
        lane_overlap_info?: ReturnType<typeof LaneOverlapInfo.prototype.toObject>;
        signal_overlap_info?: ReturnType<typeof SignalOverlapInfo.prototype.toObject>;
        stop_sign_overlap_info?: ReturnType<typeof StopSignOverlapInfo.prototype.toObject>;
        crosswalk_overlap_info?: ReturnType<typeof CrosswalkOverlapInfo.prototype.toObject>;
        junction_overlap_info?: ReturnType<typeof JunctionOverlapInfo.prototype.toObject>;
        yield_sign_overlap_info?: ReturnType<typeof YieldOverlapInfo.prototype.toObject>;
        clear_area_overlap_info?: ReturnType<typeof ClearAreaOverlapInfo.prototype.toObject>;
        speed_bump_overlap_info?: ReturnType<typeof SpeedBumpOverlapInfo.prototype.toObject>;
        parking_space_overlap_info?: ReturnType<typeof ParkingSpaceOverlapInfo.prototype.toObject>;
        pnc_junction_overlap_info?: ReturnType<typeof PNCJunctionOverlapInfo.prototype.toObject>;
        rsu_overlap_info?: ReturnType<typeof RSUOverlapInfo.prototype.toObject>;
      } = {};
      if (this.id != null) {
        data.id = this.id.toObject();
      }
      if (this.lane_overlap_info != null) {
        data.lane_overlap_info = this.lane_overlap_info.toObject();
      }
      if (this.signal_overlap_info != null) {
        data.signal_overlap_info = this.signal_overlap_info.toObject();
      }
      if (this.stop_sign_overlap_info != null) {
        data.stop_sign_overlap_info = this.stop_sign_overlap_info.toObject();
      }
      if (this.crosswalk_overlap_info != null) {
        data.crosswalk_overlap_info = this.crosswalk_overlap_info.toObject();
      }
      if (this.junction_overlap_info != null) {
        data.junction_overlap_info = this.junction_overlap_info.toObject();
      }
      if (this.yield_sign_overlap_info != null) {
        data.yield_sign_overlap_info = this.yield_sign_overlap_info.toObject();
      }
      if (this.clear_area_overlap_info != null) {
        data.clear_area_overlap_info = this.clear_area_overlap_info.toObject();
      }
      if (this.speed_bump_overlap_info != null) {
        data.speed_bump_overlap_info = this.speed_bump_overlap_info.toObject();
      }
      if (this.parking_space_overlap_info != null) {
        data.parking_space_overlap_info = this.parking_space_overlap_info.toObject();
      }
      if (this.pnc_junction_overlap_info != null) {
        data.pnc_junction_overlap_info = this.pnc_junction_overlap_info.toObject();
      }
      if (this.rsu_overlap_info != null) {
        data.rsu_overlap_info = this.rsu_overlap_info.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id !== undefined) {
        writer.writeMessage(1, this.id, () => this.id.serialize(writer));
      }
      if (this.lane_overlap_info !== undefined) {
        writer.writeMessage(3, this.lane_overlap_info, () =>
          this.lane_overlap_info.serialize(writer),
        );
      }
      if (this.signal_overlap_info !== undefined) {
        writer.writeMessage(4, this.signal_overlap_info, () =>
          this.signal_overlap_info.serialize(writer),
        );
      }
      if (this.stop_sign_overlap_info !== undefined) {
        writer.writeMessage(5, this.stop_sign_overlap_info, () =>
          this.stop_sign_overlap_info.serialize(writer),
        );
      }
      if (this.crosswalk_overlap_info !== undefined) {
        writer.writeMessage(6, this.crosswalk_overlap_info, () =>
          this.crosswalk_overlap_info.serialize(writer),
        );
      }
      if (this.junction_overlap_info !== undefined) {
        writer.writeMessage(7, this.junction_overlap_info, () =>
          this.junction_overlap_info.serialize(writer),
        );
      }
      if (this.yield_sign_overlap_info !== undefined) {
        writer.writeMessage(8, this.yield_sign_overlap_info, () =>
          this.yield_sign_overlap_info.serialize(writer),
        );
      }
      if (this.clear_area_overlap_info !== undefined) {
        writer.writeMessage(9, this.clear_area_overlap_info, () =>
          this.clear_area_overlap_info.serialize(writer),
        );
      }
      if (this.speed_bump_overlap_info !== undefined) {
        writer.writeMessage(10, this.speed_bump_overlap_info, () =>
          this.speed_bump_overlap_info.serialize(writer),
        );
      }
      if (this.parking_space_overlap_info !== undefined) {
        writer.writeMessage(11, this.parking_space_overlap_info, () =>
          this.parking_space_overlap_info.serialize(writer),
        );
      }
      if (this.pnc_junction_overlap_info !== undefined) {
        writer.writeMessage(12, this.pnc_junction_overlap_info, () =>
          this.pnc_junction_overlap_info.serialize(writer),
        );
      }
      if (this.rsu_overlap_info !== undefined) {
        writer.writeMessage(13, this.rsu_overlap_info, () =>
          this.rsu_overlap_info.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObjectOverlapInfo {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ObjectOverlapInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.id,
              () => (message.id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          case 3:
            reader.readMessage(
              message.lane_overlap_info,
              () => (message.lane_overlap_info = LaneOverlapInfo.deserialize(reader)),
            );
            break;
          case 4:
            reader.readMessage(
              message.signal_overlap_info,
              () => (message.signal_overlap_info = SignalOverlapInfo.deserialize(reader)),
            );
            break;
          case 5:
            reader.readMessage(
              message.stop_sign_overlap_info,
              () => (message.stop_sign_overlap_info = StopSignOverlapInfo.deserialize(reader)),
            );
            break;
          case 6:
            reader.readMessage(
              message.crosswalk_overlap_info,
              () => (message.crosswalk_overlap_info = CrosswalkOverlapInfo.deserialize(reader)),
            );
            break;
          case 7:
            reader.readMessage(
              message.junction_overlap_info,
              () => (message.junction_overlap_info = JunctionOverlapInfo.deserialize(reader)),
            );
            break;
          case 8:
            reader.readMessage(
              message.yield_sign_overlap_info,
              () => (message.yield_sign_overlap_info = YieldOverlapInfo.deserialize(reader)),
            );
            break;
          case 9:
            reader.readMessage(
              message.clear_area_overlap_info,
              () => (message.clear_area_overlap_info = ClearAreaOverlapInfo.deserialize(reader)),
            );
            break;
          case 10:
            reader.readMessage(
              message.speed_bump_overlap_info,
              () => (message.speed_bump_overlap_info = SpeedBumpOverlapInfo.deserialize(reader)),
            );
            break;
          case 11:
            reader.readMessage(
              message.parking_space_overlap_info,
              () =>
                (message.parking_space_overlap_info = ParkingSpaceOverlapInfo.deserialize(reader)),
            );
            break;
          case 12:
            reader.readMessage(
              message.pnc_junction_overlap_info,
              () =>
                (message.pnc_junction_overlap_info = PNCJunctionOverlapInfo.deserialize(reader)),
            );
            break;
          case 13:
            reader.readMessage(
              message.rsu_overlap_info,
              () => (message.rsu_overlap_info = RSUOverlapInfo.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): ObjectOverlapInfo {
      return ObjectOverlapInfo.deserialize(bytes);
    }
  }
  export class Overlap extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            id?: dependency_1.atlas.hdmap.Id;
            object: ObjectOverlapInfo[];
            region_overlap: RegionOverlapInfo[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], []);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("id" in data && data.id != undefined) {
          this.id = data.id;
        }
        this.object = data.object;
        this.region_overlap = data.region_overlap;
      }
    }
    get id() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.hdmap.Id, 1);
    }
    set id(value: dependency_1.atlas.hdmap.Id) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get object() {
      return pb_1.Message.getRepeatedWrapperField(this, ObjectOverlapInfo, 2);
    }
    set object(value: ObjectOverlapInfo[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get region_overlap() {
      return pb_1.Message.getRepeatedWrapperField(this, RegionOverlapInfo, 3);
    }
    set region_overlap(value: RegionOverlapInfo[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    static fromObject(data: {
      id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
      object: ReturnType<typeof ObjectOverlapInfo.prototype.toObject>[];
      region_overlap: ReturnType<typeof RegionOverlapInfo.prototype.toObject>[];
    }) {
      const message = new Overlap({
        object: data.object.map((item) => ObjectOverlapInfo.fromObject(item)),
        region_overlap: data.region_overlap.map((item) => RegionOverlapInfo.fromObject(item)),
      });
      if (data.id != null) {
        message.id = dependency_1.atlas.hdmap.Id.fromObject(data.id);
      }
      return message;
    }
    toObject() {
      const data: {
        id?: ReturnType<typeof dependency_1.atlas.hdmap.Id.prototype.toObject>;
        object: ReturnType<typeof ObjectOverlapInfo.prototype.toObject>[];
        region_overlap: ReturnType<typeof RegionOverlapInfo.prototype.toObject>[];
      } = {
        object: this.object.map((item: ObjectOverlapInfo) => item.toObject()),
        region_overlap: this.region_overlap.map((item: RegionOverlapInfo) => item.toObject()),
      };
      if (this.id != null) {
        data.id = this.id.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id !== undefined) {
        writer.writeMessage(1, this.id, () => this.id.serialize(writer));
      }
      if (this.object !== undefined) {
        writer.writeRepeatedMessage(2, this.object, (item: ObjectOverlapInfo) =>
          item.serialize(writer),
        );
      }
      if (this.region_overlap !== undefined) {
        writer.writeRepeatedMessage(3, this.region_overlap, (item: RegionOverlapInfo) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Overlap {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Overlap();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.id,
              () => (message.id = dependency_1.atlas.hdmap.Id.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(message.object, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                ObjectOverlapInfo.deserialize(reader),
                ObjectOverlapInfo,
              ),
            );
            break;
          case 3:
            reader.readMessage(message.region_overlap, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                3,
                RegionOverlapInfo.deserialize(reader),
                RegionOverlapInfo,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Overlap {
      return Overlap.deserialize(bytes);
    }
  }
}
