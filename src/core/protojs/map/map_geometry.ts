// This Source Code Form is subject to the terms of the Mozilla Public
// License, v2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.1
 * source: map/map_geometry.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

import * as dependency_1 from "./../common/geometry";

export namespace atlas.hdmap {
  export class Polygon extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            point: dependency_1.atlas.common.PointENU[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
      if (!Array.isArray(data) && typeof data == "object") {
        this.point = data.point;
      }
    }
    get point() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.common.PointENU, 1);
    }
    set point(value: dependency_1.atlas.common.PointENU[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      point: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>[];
    }) {
      const message = new Polygon({
        point: data.point.map((item) => dependency_1.atlas.common.PointENU.fromObject(item)),
      });
      return message;
    }
    toObject() {
      const data: {
        point: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>[];
      } = {
        point: this.point.map((item: dependency_1.atlas.common.PointENU) => item.toObject()),
      };
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.point !== undefined) {
        writer.writeRepeatedMessage(1, this.point, (item: dependency_1.atlas.common.PointENU) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Polygon {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Polygon();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.point, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                dependency_1.atlas.common.PointENU.deserialize(reader),
                dependency_1.atlas.common.PointENU,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Polygon {
      return Polygon.deserialize(bytes);
    }
  }
  export class LineSegment extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            point: dependency_1.atlas.common.PointENU[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
      if (!Array.isArray(data) && typeof data == "object") {
        this.point = data.point;
      }
    }
    get point() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_1.atlas.common.PointENU, 1);
    }
    set point(value: dependency_1.atlas.common.PointENU[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      point: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>[];
    }) {
      const message = new LineSegment({
        point: data.point.map((item) => dependency_1.atlas.common.PointENU.fromObject(item)),
      });
      return message;
    }
    toObject() {
      const data: {
        point: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>[];
      } = {
        point: this.point.map((item: dependency_1.atlas.common.PointENU) => item.toObject()),
      };
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.point !== undefined) {
        writer.writeRepeatedMessage(1, this.point, (item: dependency_1.atlas.common.PointENU) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LineSegment {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new LineSegment();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.point, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                dependency_1.atlas.common.PointENU.deserialize(reader),
                dependency_1.atlas.common.PointENU,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): LineSegment {
      return LineSegment.deserialize(bytes);
    }
  }
  export class CurveSegment extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | ({
            s?: number;
            start_position?: dependency_1.atlas.common.PointENU;
            heading?: number;
            length?: number;
          } & {
            line_segment?: LineSegment;
          }),
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("line_segment" in data && data.line_segment != undefined) {
          this.line_segment = data.line_segment;
        }
        if ("s" in data && data.s != undefined) {
          this.s = data.s;
        }
        if ("start_position" in data && data.start_position != undefined) {
          this.start_position = data.start_position;
        }
        if ("heading" in data && data.heading != undefined) {
          this.heading = data.heading;
        }
        if ("length" in data && data.length != undefined) {
          this.length = data.length;
        }
      }
    }
    get line_segment() {
      return pb_1.Message.getWrapperField(this, LineSegment, 1);
    }
    set line_segment(value: LineSegment) {
      pb_1.Message.setOneofWrapperField(this, 1, [1], value);
    }
    get s() {
      return pb_1.Message.getField(this, 6) as number;
    }
    set s(value: number) {
      pb_1.Message.setField(this, 6, value);
    }
    get start_position() {
      return pb_1.Message.getWrapperField(this, dependency_1.atlas.common.PointENU, 7);
    }
    set start_position(value: dependency_1.atlas.common.PointENU) {
      pb_1.Message.setWrapperField(this, 7, value);
    }
    get heading() {
      return pb_1.Message.getField(this, 8) as number;
    }
    set heading(value: number) {
      pb_1.Message.setField(this, 8, value);
    }
    get length() {
      return pb_1.Message.getField(this, 9) as number;
    }
    set length(value: number) {
      pb_1.Message.setField(this, 9, value);
    }
    get curve_type() {
      const cases: {
        [index: number]: "none" | "line_segment";
      } = {
        0: "none",
        1: "line_segment",
      };
      return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
      line_segment?: ReturnType<typeof LineSegment.prototype.toObject>;
      s?: number;
      start_position?: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>;
      heading?: number;
      length?: number;
    }) {
      const message = new CurveSegment({});
      if (data.line_segment != null) {
        message.line_segment = LineSegment.fromObject(data.line_segment);
      }
      if (data.s != null) {
        message.s = data.s;
      }
      if (data.start_position != null) {
        message.start_position = dependency_1.atlas.common.PointENU.fromObject(data.start_position);
      }
      if (data.heading != null) {
        message.heading = data.heading;
      }
      if (data.length != null) {
        message.length = data.length;
      }
      return message;
    }
    toObject() {
      const data: {
        line_segment?: ReturnType<typeof LineSegment.prototype.toObject>;
        s?: number;
        start_position?: ReturnType<typeof dependency_1.atlas.common.PointENU.prototype.toObject>;
        heading?: number;
        length?: number;
      } = {};
      if (this.line_segment != null) {
        data.line_segment = this.line_segment.toObject();
      }
      if (this.s != null) {
        data.s = this.s;
      }
      if (this.start_position != null) {
        data.start_position = this.start_position.toObject();
      }
      if (this.heading != null) {
        data.heading = this.heading;
      }
      if (this.length != null) {
        data.length = this.length;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.line_segment !== undefined) {
        writer.writeMessage(1, this.line_segment, () => this.line_segment.serialize(writer));
      }
      if (this.s !== undefined) {
        writer.writeDouble(6, this.s);
      }
      if (this.start_position !== undefined) {
        writer.writeMessage(7, this.start_position, () => this.start_position.serialize(writer));
      }
      if (this.heading !== undefined) {
        writer.writeDouble(8, this.heading);
      }
      if (this.length !== undefined) {
        writer.writeDouble(9, this.length);
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CurveSegment {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new CurveSegment();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.line_segment,
              () => (message.line_segment = LineSegment.deserialize(reader)),
            );
            break;
          case 6:
            message.s = reader.readDouble();
            break;
          case 7:
            reader.readMessage(
              message.start_position,
              () =>
                (message.start_position = dependency_1.atlas.common.PointENU.deserialize(reader)),
            );
            break;
          case 8:
            message.heading = reader.readDouble();
            break;
          case 9:
            message.length = reader.readDouble();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): CurveSegment {
      return CurveSegment.deserialize(bytes);
    }
  }
  export class Curve extends pb_1.Message {
    constructor(
      data?:
        | any[]
        | {
            segment: CurveSegment[];
          },
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
      if (!Array.isArray(data) && typeof data == "object") {
        this.segment = data.segment;
      }
    }
    get segment() {
      return pb_1.Message.getRepeatedWrapperField(this, CurveSegment, 1);
    }
    set segment(value: CurveSegment[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: { segment: ReturnType<typeof CurveSegment.prototype.toObject>[] }) {
      const message = new Curve({
        segment: data.segment.map((item) => CurveSegment.fromObject(item)),
      });
      return message;
    }
    toObject() {
      const data: {
        segment: ReturnType<typeof CurveSegment.prototype.toObject>[];
      } = {
        segment: this.segment.map((item: CurveSegment) => item.toObject()),
      };
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.segment !== undefined) {
        writer.writeRepeatedMessage(1, this.segment, (item: CurveSegment) =>
          item.serialize(writer),
        );
      }
      if (!w) {
        return writer.getResultBuffer();
      }
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Curve {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Curve();
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.segment, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                CurveSegment.deserialize(reader),
                CurveSegment,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Curve {
      return Curve.deserialize(bytes);
    }
  }
}
